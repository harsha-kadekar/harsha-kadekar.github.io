---
category: Technical
date: 2026-02-15
layout: post
tags:
- llm
title: Notes On Learning to Code With LLMs - 2026-02-15
updated: 2026-02-15
---

I have started my journey to understand and learn to use LLM tools for the software engineering work. My belief is it helps in multiple ways for a software developer - writing code, reviewing code, debugging issues, planning tasks, researching about topics. From what I have read, it takes effort and time to get a better hold on these tools. These series of notes are my understandings, gotchas, learnings of this journey. These notes will not have any fixed schedule for publishing. Whenever I try things, I learn stuff, I will publish them. I want to build stuff and learn from it. As required, to better understand or improve something, I will go ahead and learn some theory related to LLM and if possible apply that knowledge to building things. I will use LLM to review these posts but these will be my own thoughts. So, let's start -

I am currently using Claude Code and I have Pro subscription. I am right now trying to build a mobile app for tracking my dhyana sessions. Here are my learnings from this session.
- Learnt that we have a planning mode in the Claude Code. I can go into it by using `shift + tab`. I learned about it primarily from [inverted passion blog post](https://invertedpassion.com/my-claude-code-workflow/) and also I had read from other x posts & blogs. In this mode, you are basically trying to discuss with a colleague to better understand your idea, expand the thoughts, finally iron out the requirements, come up with the milestones and finally generate list of simple actionable tasks to achieve those milestones. 
- As I interacted with the Claude, I felt things that used to take a lot of time in research and decision making has reduced a lot. If LLM was not there and I am starting it out alone, the amount of research I had to make as well as number of choices I have to go through to finalize on some approach is significant and many times it would have led to decision paralysis. I would not have moved further. With LLM, this completely collapses. LLM gives you finite options with simple pros and cons. It also helps me to drive down to understand better about the choices. 
	- There was one thought that lingered on. While making decision, we used to talk to multiple people to get varying point of view. And then finally we used to make a decision or choice. With the LLM, it felt like I am only talking to just one person. As a result, less confidence on the choice to take. If there is some experimental offering which exactly suits my use-case but not well known, LLM might not know about it, and chances are it won't even mention it. I guess even for human interaction same may apply. Just that, I felt this.
- As I chatted with LLM, clearer ideas started coming in. So, this discussion is forcing me to think through more or make a conscious effort to understand my own thoughts. It's like writing to some extent where I am trying to clarify my own requirements and understanding. 
- Once it generated the milestones and individual tasks, I reviewed it. I had to explicitly state that put it in a doc for reference for me and also had to ask it to put it in some tracking mechanism like github issues. It chose github issues but I don't see that it has actually added them yet. But, it is saying it has already completed implementation. So, probably it is best to give this instruction as requirement of the project setup itself to handle it via github issues. As it completes individual task/milestone, update github issues to see the progress. 
	- So, I need to prompt in such a way that I can actually go through one by one atomic tasks. Ask it to complete one atomic task, review it with me and then go ahead with next one. Otherwise lot of work would have been done and it would be difficult to follow through. 
- It was about to push the code to git repo and then I asked what kind of validation has been done. It reported nothing is done on validation. This was a red light for me. I had to ask it to validate it and then it had some issues. 
	- So, probably I should make a mechanism such that these need to be done by default when writing code unless explicitly stated not to do. We should reverse it. Like without tests written, executed and validated, do not push to github repo. When trying to install some software, ASK the user to do it rather than try it yourself. 
	- There is a fine balance as well, we need to give some freedom for faster development but we also need control on what is being done to better judge. Example, asking permissions to read from web or executing some of the python commands or tasks could be done without asking for permission as long as it is only touching its current working directory. But it needs to ask permission for going to new milestone or task, for installing apps, etc. 
- It has produced a lot of code. In fact, my daily limit got breached and had to stop it. But, I do not understand the code yet. I need to read through the code, understand it and then only allow it to push to the github.