---
permalink: /books/
title: "Books"
toc: true
---

I read various kinds of books. It has taught me a lot and has been guiding me. One of the things I observed was, after reading the book I forget most of its content or main idea within few days. Also if the book was big and I took long time to finish it, by the time I reached the end of the book, I would have forgotten what I read in the beginning of the book. So it would be a good thought exercise for me to recap the book's content and write down the gist of it. So this page will hold the small gist or learnings I took away from reading that book.
{: style="text-align: justify;"}

All the books I read are bookmarked in [GoodReads](https://www.goodreads.com/harsha_kadekar)

### Release It! Design and Deploy Production-Ready Software
- Author: **Michael T. Nygard**
- GoodReads: [Release It!](https://www.goodreads.com/book/show/1069827.Release_It_)

As the name of the book implies, the main topic of this book is about how you will design your applications and services such that it can be deployed and maintained in a production environment. There are multiple factors which help for a good design 
* The stress, impulses or component failures will affect the integeration points of the application. And these integeration points will fail and this failure will spread to other parts of the application.
* Whenever you are connecting to remote applications or databases via sockets or RMI or any means we need to protect these connections with timeouts. These remote calls are unpredictable - it can fail with an error, it can take a lot of time to return or it can fail silently. So better to protect them with timeouts.
* Use circuit breakers to protect from the impulses, stress. Make sure there is way to know whether circuit breaker is activated - some kind of metric or alarm is needed.
* In web applications use sessions judiciously. Each session resides in the memory and it will reside for long time even if it is not used.
* If you are expecting high demand for certain resources or functionality then protect it such that those demands are diverted to a separate resource thus protecting the other functionality and components from getting affected due to resource crunch.
* Always use connection pool to connect to a resource whether it is multiple instances of services or database.
* Use ORM to connect and operate to the database. Never directly run a direct SQL query from your application.
* Before releasing to production do a load testing. And remember your development envrionment and QA environment will never be able to match scale of production. Rather than trying to match the scale of production, design your application code such that even in the hightened requests or stress, application should be able to transact.
* Slow responses from your application will lead to other problems like more traffic and customers will keep retrying and more resources are utilized leading to cascading failures. 
* Fail fast is better than slow responses.
* For slow responses, reason could be memory leaks or resource contentions like DB pool is filled up or thread pool is filled up.
* Do not blindly put an SLA to your services. Measure it. Understand the SLA of your dependent services. Based on that derive your SLA. You cannot give an SLA which is better than your dependent service.
* Use bulkheads in case of failures, so that even if some components fail your product is still running and insulated from the failed components.
* Caching has limits. It increases your services response to certain extent after that it will eat your memory and thus leading to decrease in response. So use it carefully.
* Make sure you clean up your old logs. Either move to a different location but do not allow it fill up space.
* Clean up your old data. Maintain data hygiene. 
* All these disk cleanup and application data clean up has to happen automatically via your application rather than human intervention.
* When you test, do not just go by your requirements. Go out of requirements when testing negative failure scenario. 
* Try to use intelligent load balancers that consistently does health checks of the underlying systems and based on bad health stops sending requests to those instances.
* Try to provide an adminstrative CLI tool for every service for ops work.
* Set up alarms and monitors like for system health, requests recieved, response time, max threads, max connections. There should be dashboard to monitor these metrics and alarms to give real time picture of what is happenning to your service or application. Logs are a great way to learn about what is happening but metrics & alarms give you high level picture of what is going on. Also have tools which will read your logs and alarms based on specific stack trace occurrence such as exceptions or faults being reported in logs.
* Releases should be done often and all the release activity should be automated - aim for continuous deployment.


### ಶಿಕಾರಿ Shikari
- Author: **Yashwant Chittal**
- GoodReads: [ಶಿಕಾರಿ Shikari](https://www.goodreads.com/book/show/25657010-shikari)

The book is about corporate politics. The main protagonist is hunted (ಶಿಕಾರಿ Shikari) from multiple directions. The narration of the story is also very different, as in everything is happening through the view point of the hero. It's as if I am part of the mind of the hero and listening to every thought that is getting generated in his mind. It gives clear picture of how the game of corporate politics and it's fight are fought, how each human relation is utilized for acheiving something in the corporate world, how a person becomes a pawn between the fights of heads. The thing which stood out is how it gives a clear picture of human greed and selfish nature. The moment when a person is in the path of losing, everyone will swoop in like vultures to take their revenge and also the moment humans come to know that you are a losing side, they will shift their allegiance. You and you alone are your friend. Its a good read.
{: style="text-align: justify;"}


### The Little Book Of Common Sense Investing
- Author: **John C Bogle**
- GoodReads: [The Little Book Of Common Sense Investing](https://www.goodreads.com/book/show/34003072-the-little-book-of-common-sense-investing)

Jobh C Bogle is founder and ex-chairman of Vangaurd. In this book he makes a very strong case for investing in low cost index funds. He gives lot of reasons why we should not try to trump the market returns. Following are the learnings I take from this book:
1. Do not do short term investing. Always aim for long term investing.
2. Investment should be diversified. A person will secure his returns if he owns all of the business available in the market.
3. Do not try to choose individual stocks and invest in it. It is a loosing game. Now index funds will provide the necessary diversification.
4. When you are investing, invest in low cost index funds which will provide the diversification and also has low cost, interms of tax and managing. Do not invest in high cost mutual/equity funds which would eat up all the returns in the cost of maintaining it. So only fund managers will earn money in it.
5. ETF are good option as long as it is targetted towards diversified portfolio like S&P 500 or US Total Stock market. These ETF should be again long term investments and not short term investments.
6. Remember your returns include the dividends which you get from investing in the fund. Those dividends should also be ideally reinvested. 
7. Initially when you start investing you should have ideally 80/20 Index Fund/Bond investment. As you progress towards your retirements, this share needs to be changed. Usually the ratio will reverse. 
8. From time to time you need to evaluate your investments and maintain that investment ratio. This investment can be still diversified like 40% in US Index Funds, 20% in Non US Market Funds and 20% in Bonds.
9. Remember do not invest emotionally. The market has a mean reversion - Every time market goes up it will come back down to its normal trajectory, similarly everytime market goes down it will come back up to its normal trajectory.


### Light on the Yoga Sūtras of Patañjali
- Author: **Patañjali (Commentator & Translator: B K S Iyengar)**
- GoodReads: [Light on the Yoga Sūtras of Patañjali](https://www.goodreads.com/book/show/139352.Light_on_the_Yoga_S_tras_of_Pata_jali)

B.K.S. Iyengar is famous for his Yoga practices. In this book, he has not only provided literal English translation of each of the sūtras, but also gives detailed explanation and commentary on it. The book gives systematic steps a person needs to take to achieve the Kaivalya ( individual self merges to universal self). There are different stages which the saadhaka needs to pass through by continuous saadhana. Every person based on his previous Saadhana and their nature, we can classify their level to 4 sections. In Yoga Sūtras, Patañjali has given four sections (Pāda) - Samadhi Pada, Saadhana Pada, Vibhuti Pada and Kaivalya Pada which can be adopted based on the maturity of practitioner. B.K.S. Iyengar explains the similarities between Bhagavad Geeta and Yoga Sutras. 
{: style="text-align: justify;"}

B.K.S. Iyengar gives one of the best explanation for the Abhyasa and Vairagya - "Abhyasa is a dedicated, unswerving, constant, and vigilant search into a chosen subject, pursued against all odds in the face of repeated failures for indefinitely long period of time. Vairagya is the cultivation of freedom from passion, abstention from worldly desires and appetites, and discrimination between real and the unreal. It is the act of giving up all sensuous delights. Abhyasa builds confidence and refinement in the process of culturing the consciousness, whereas vairagya is the elimination of whatever hinders progress and refinement. Proficiency in vairagya develops the ability to free oneself from the fruits of action." 
{: style="text-align: justify;"}

BKS also explains the importance of self discipline for a Saadhaka. Yoga is for reaching perfection in a human by means of using himself as the tool. "The disciplines of purifying man's three constituents, body, speech and mind constitute kriyayoga, the path to perfection. Our bodies are purified by self-discipline (tapas), our works by Self-study (svadhyaya) and our minds by love and surrender to Him (Isvara pranidhana)". One of the main misconception previaling is equating Yoga to asana. Asana is just small part of yoga,whereas Yoga is a whole system consisting of many things which needs to be practiced and cultivated to achieve the ultimate goal of Kaivalya. Yoga practioner gains following knowledge -  knowledge of the body, knowledge of energy, knoweldge of controlling the mind, stability in intelligence, knowledge gained by experience, absorption of the various flavours that life offers and knowledge of the self. By yogic practices the sadhaka conqures his body, controls his energy, restrains the movements of the mind and develops sound judgement, from which he acts rightly and becomes luminous. From this luminosity he develops total awareness of the very core of his being, achieves supreme knowledge, and surrenders his self to the Supreme Soul. 
{: style="text-align: justify;"}

As part of Yoga, we need to practice following things - Yama ( satya, ahimsa, non stealing, brahmacharya, freedom from avarice or non covetousness), Niyama (sauca - cleanliness, santosha - contentment, tapas - religious fervour, svadhyaya - study of scriptures & self, Isvara Parindhana - surrender of self to God), Asana, Pranayama and Pratyahara (Dharana, Dhyana and Samadhi). 
{: style="text-align: justify;"}

Dharana is concentration - pointed focus on something. Maintaining that concentration will lead to Dhyana. "When the object of contemplation shines forth without the intervention of one's own consciousness, dhyana flows into samadhi. When a musician loses himself and is completely engrossed in his music, or an inventor makes his discoveries when devoid of ego, or a painter transcends himself with colour, shade and brush; they glimpse samadhi. Similarly it is with the yogi: when his object of contemplation becomes himself, devoid of himself, he experiences samadhi." The difference is that the artist or musician reaches this state by effort and cannot sustain it; whereas the yogi, remaining devoid of ego, experiences it as natural, continuous and effortless. Consequently, it is difficult for an artist to infuse his vision of the sublime, which is associated with the performance and realization of a particular art form into his ordinary daily existence. For the yogi, however, whose 'art' is formless and whose goal has no physical expression like a painting, a book or a symphony, the fragrance of samadhi penetrates every aspect of his normal behaviour, activities and state of being.  Uninterrupted flow of attention dissolves the split between the object seen and the seer who sees it. Consciousness appears to have ceased, and to have reached a state of silence. It is devoid of 'I', and merges into the core of the being in a profound state of serenity. In samadhi, awareness of place vanishes and one ceases to experience space and time. When one contemplates a diamond, he at first sees with great clarity the gem itself. Gradually one becomes aware of the light glowing from its centre. As awareness of the light glows, awareness of the stone as an object diminishes. Then there is only brightness, no source, no object. When the light is everywhere that is samadhi.
{: style="text-align: justify;"}


### The Mythical Man-Month: Essays on Software Engineering
- Author: **Frederick P. Brooks Jr.**
- GoodReads: [The Mythical Man Month Essays on Software Engineering](https://www.goodreads.com/book/show/13629.The_Mythical_Man_Month)

This is considered as one of the classics of  Software Engineering. These are my take away from this book - 

* It is usually advertised that few programmers in a garage have developed a program which surpasses the best effort of large teams of a company - Do not believe that. There is a large difference between program and product/application/system. It takes a lot of effort to move the program to a product/system/application.  
* What is it that makes a person to create programs - sheer joy of creating things, sheer joy of making things that is useful to others, joy of developing or imagining the complex systems and make it work - like solving a puzzle, joy of  learning as every time its a new thing we learn as tasks become non-repetitive. 
* When we are estimating a task, the general tendency is assuming everything is going to be well and only estimating for the coding. There are 3 parts in the creation - idea, implementation and interaction with real world. When we give estimates, we assume that our idea is perfect and implementation will be very easy. But usually idea will not be bug free and real challenges starts appearing once we start the implementation. So when estimating, think of iterations of 3 parts, i.e take into account - planning, coding and testing. More time should be devoted to planning and testing. This type of estimate should be done for each task.
* We should not equate the effort spent on a work to be equivalent of progress done in that work
* Man and Month are interchangeable  only when each task can be divided such that there is no need for communication. For most of the time as more men means tasks needs to be divided and each task may not be perfectly independent of each other. So if we estimate for a task that it takes x days for a single developer, it does not mean it is going to take x/2 days for two developers. The common mistake is adding more people to a late project to make the deadline achievable. But this is a mistake, adding more people to a late project will most probably will make it take a longer time. Adding people has two affects, new people have a learning curve and adds extra communication requirement. So immediate effect of adding more people is negative. So better to add more people in the early stage of the project. 
* When a project is not finished in time(food ordered in hotel), there are 3 possible things - 1. Give it as it is, that is it will be missing some features (half baked food) 2. Wait till the product finishes (wait for the full completion of the food) 3. Add more people to make it finish within the time line (increase the burner to cook it fast). The general tendency is to go with 3rd option which will always result in burned up product (burned up in one side and half baked in another side so totally a disaster). So best option is always 2nd option - wait till it finishes i.e extend the deadline. Next best is always for the releasing with limited features. 
* Until estimating is on a sounder basis, software managers should defend their estimates that their hunches are better than wish derived estimates. 
* Always have smaller teams. In the team for a product, there should be a single main developer who will be responsible for the design. This developer should be responsible for settling any queries related to design or architecture of the team. The others in the team should help this designer. Similarly the main developer will take help and suggestions from his team. So always have a small and good programming team.  The architect/designer holds final decision and authority on the changes. Even during the meetings that chain should be well established to make the meeting fruitful. In the meeting everyone is allowed to discuss and propose the solutions which may be inside the boundary or outside. It is essential to encourage others to ask questions to the architect instead of assuming things. 
* If you are designing a module or product and the implementation will be done by others, then provide a possible implementation for it. Also be ready to accept the changed implementation done by the implementer as long as it sticks to the design.
* If you achieve conceptual integrity in product design then simplicity will be automatically achieved. Even though a product may be developed by multiple persons in a team,  but it should be developed such that for an external user it should be perceived as developed by a single mind. So it would be better that single person in the team should own the design of the product. One of the main ingredient of the successful product is having conceptual integrity.
* As we add more features to a single product, it will reduce the usability of the product. As a designer or product owner, we want to add more and more features to it. After some point this will result in loosing conceptual integrity of the product and will have negative effect. 
* There are six ingredients of a successful product - clear mission, enough man power, enough time, enough materials, adequate technology and clear communication. 
* The organization is there to help reduce the unnecessary communications and extra coordination which gets added as man power gets added. 
* For any team there are two aspects - technical and management.  So for each of them we need a point of contact - technical (director/architect), management (producer/ manager). Now these two roles can be done by a single person or it could be two different persons - one working under other (producer under director or director under producer). Manager's work is mainly communication outside the team where as director or architect communication is within the team. Manager is responsible for getting the resources, establishing schedule, gathering team, dividing work. The Architect/director is responsible for design of the product, coming up with the sub designs, clearing the technical challenges.  
* Before starting the program or product, along with the design, define the restriction under which that product needs to work. The restrictions like memory consumption limit, latency limits, CPU utilization limits, request limits.
* Forecast -> Estimate -> Price -> Forecast .This is a cycle. To generate forecast we need the postulated prices. Based on the forecast and the number of units, we derive the cost estimate. Then based on the estimate we set the price. 
* In most of the projects, the first product that comes out is barely usable. It will have lot of bugs, memory issues, may be awkward, big or small or not covering needed requirements.  So start with a prototype. After prototype, then only go with actual delivery. Develop the product with change in mind. The product grows and change is constant. 
* The reluctance to document a design is not merely for laziness or time pressure but also due to not wanting to commit to a design.  Any architect or designer should be ready to expose whole of the design, ready to defend everything he writes and expose himself to criticism. Organization should help architect to achieve it and also make sure that architect is not threatened to take the responsibility. 
* Each person in team should be given the job which will broaden them. 
* In an organization or team, managers and technical people should be interchangeable as their talent allow. Sociological barriers for bringing this into effect are - 1. Managers often think of senior people as too valuable to use for actual programming. 2. Management jobs carry higher prestige. To tackle this maintain dual ladder of advancement - Managerial Ladder (Senior Software Development Engineer -> Manager -> Senior Manager -> Vice President) , Technical Ladder (Senior Software Development Engineer -> Principal Engineer -> Senior Principal Engineer -> Director) . Corresponding Levels should have same base pay example - Manager and Principal Engineer should have same base pay salary  and other org support. A reassignment from the technical ladder to corresponding level on managerial ladder should never be accompanied by a raise as it is a reassignment and not a promotion.  Managers need to be sent to technical refresher courses, and technical people to management training. Project objectives, progress, technical problems and management problems must be shared with the whole body of senior people. Whenever talents permit, senior people must be kept technically and emotionally ready to manage groups or to delight in building programs with their own hands.  
* Total cost of maintaining a delivered product is nearly 40% of the production cost. Most of the maintenance will be related to fixing design bugs. Usually as we go about fixing the bugs and releasing new versions, the total incoming bugs reduces and after certain point this incoming bug rate will again start increasing due to some reasons like - 
	- users have learnt the product fully and are utilizing it completely and hence new bugs are found, 
	- design has reached its limits, so fixes are introducing newer bugs. 
* Test driven development is needed to build the product which does what is intended to to do.
* When one hears of disastrous schedule slippage in a project, he imagines that a series of major calamities must have befallen it. Usually the disaster is due to termites, not tornadoes.  The day by day slippage is harder to recognize, harder to prevent, harder to make up. Each one of the team would have postponed their activity by a half-day or a day but overall project would have slipped one day at a time. 
* We need to have a schedule for a project. The schedule should be divided into milestones. Milestones must be concrete, specific, measurable events defined with knife edge sharpness. Rarely will a man lie about milestone progress, if the milestone is so sharp that he can't deceive himself. If the milestone is fuzzy than boss will understand different report from that which the man gives. No one enjoys bearing bad news either, so it gets softened without any real intent to deceive. 
* We should clearly know which other modules are dependent on our module. So when we have a day slip in our module, that is going to have snow ball affect on modules that depend on us. 
* Every manager should get two kinds of information from direct reporters - action information and status information. Status information is just an education of what is going on and what is the current status of each items or milestones. This status information might have some red signals but manager or boss should not act on it. The first line manager or engineer who is reporting will take necessary action by himself. Only action information needs to be taken up by the Manager and act on it. We need to empower the first line managers and engineers to take ownership, own their tasks, work on issues and roadblocks but we need to have clear picture of what is going on. Only when the manager/engineer knows his boss will accept status reports without panic or preemption, he comes to give honest status. 
* The power should be delegated to individual teams. Any success or failure the team should own it. Any problems within the team needs to be settled within the team. The teams need to be empowered. The team should own the schedule of the project/product. They should have a process for this, either their own way or company followed standards. "The center gains in real authority by delegating power, and organization as a whole will be more happier and prosperous."
* On large projects manager needs to keep 2 or 3 top programmers as a technical cavalry that can gallop to the rescue whenever the battle is thickest.  
* One of the important factors that will determine a success of a team is its quality.  More than better tools it is the team dynamics that matter - how the team is looked after, feeding them and taking care of their needs. Managers work is not to make people work but rather make it possible for people to work. The top performer's workspace is more quieter, more private and better protected from interruption. So manager should target to achieve that for their teams - less interruption and quieter environment for the team.  